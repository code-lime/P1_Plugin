package org.lime.gp.player.module.food;

import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.network.protocol.game.PacketPlayOutUpdateHealth;
import net.minecraft.server.level.EntityPlayer;
import net.minecraft.world.EnumDifficulty;
import net.minecraft.world.entity.player.EntityHuman;
import net.minecraft.world.food.FoodMetaData;
import net.minecraft.world.food.IFoodNative;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import org.bukkit.Bukkit;
import org.bukkit.craftbukkit.v1_19_R3.entity.CraftPlayer;
import org.bukkit.craftbukkit.v1_19_R3.event.CraftEventFactory;
import org.bukkit.entity.Player;
import org.bukkit.event.entity.FoodLevelChangeEvent;
import org.lime.core;
import org.lime.gp.access.ReflectionAccess;
import org.lime.gp.item.Items;
import org.lime.gp.item.settings.list.FoodSetting;
import org.lime.gp.lime;
import org.lime.gp.town.ChurchManager;

import java.util.Optional;

public class AnyProxyFoodMetaData extends FoodMetaData {
    public static core.element create() {
        return core.element.create(AnyProxyFoodMetaData.class)
                .withInit(AnyProxyFoodMetaData::init);
    }
    private static void init() {
        lime.repeat(AnyProxyFoodMetaData::update, 0.2);
    }
    private static void update() {
        Bukkit.getOnlinePlayers().forEach(player -> {
            EntityPlayer eplayer = ((CraftPlayer)player).getHandle();
            AnyProxyFoodMetaData metaData = getProxyFood(eplayer);
            if (ChurchManager.hasAnyEffect(player, ChurchManager.EffectType.SATURATION)) {
                metaData.saturationStep = 0.5f;
                metaData.foodStep = 0.5f;
            } else {
                metaData.saturationStep = 1;
                metaData.foodStep = 1;
            }
        });
    }

    private static AnyProxyFoodMetaData getProxyFood(EntityPlayer eplayer) {
        FoodMetaData data = eplayer.getFoodData();
        if (data instanceof AnyProxyFoodMetaData metaData) return metaData;
        if (data.getClass() != FoodMetaData.class) data = org.lime.reflection.getField(data.getClass(), "base", data);
        AnyProxyFoodMetaData proxy = new AnyProxyFoodMetaData(data);
        ReflectionAccess.foodData_EntityHuman.set(eplayer, proxy);
        return proxy;
    }

    private final FoodMetaData base;

    private float doubleFood;
    private EntityHuman human;

    public float foodStep = 1;
    public float saturationStep = 1;

    private AnyProxyFoodMetaData(EntityHuman human, FoodMetaData base) {
        super(human);
        this.human = human;
        this.base = base;
        this.doubleFood = base.getFoodLevel();
    }
    public AnyProxyFoodMetaData(FoodMetaData base) {
        this(ReflectionAccess.entityhuman_FoodMetaData.get(base), base);
        lime.logOP("IS NATIVE: " + (base instanceof IFoodNative));
    }
    private void onFoodEdit() {
        doubleFood = this.base.foodLevel;
        foodLevel = this.base.foodLevel;
    }
    private void sync() {
        foodLevel = base.foodLevel;
        saturationLevel = base.saturationLevel;
        exhaustionLevel = base.exhaustionLevel;
        saturatedRegenRate = base.saturatedRegenRate;
        unsaturatedRegenRate = base.unsaturatedRegenRate;
        starvationRate = base.starvationRate;
    }

    @Override public void eat(int food, float saturationModifier) {
        base.eat(food, saturationModifier);
        onFoodEdit();
    }
    public void eat(float food, float saturationModifier) {
        this.doubleFood = Math.max(food + this.doubleFood, 0);
        base.foodLevel = this.foodLevel = (int)this.doubleFood;
        base.saturationLevel = this.saturationLevel = Math.min(this.saturationLevel + food * saturationModifier * 2.0f, (float)this.foodLevel);
    }
    @Override public void eat(Item item, ItemStack stack) {
        Items.getOptional(FoodSetting.class, stack).ifPresentOrElse(info -> {
            if (item.isEdible()) {
                float oldFoodLevel = doubleFood;
                float food = Math.max(info.value + oldFoodLevel, 0);
                int _food = (int)food;
                FoodLevelChangeEvent event = CraftEventFactory.callFoodLevelChangeEvent(human, _food, stack);
                if (!event.isCancelled()) {
                    this.eat((event.getFoodLevel() == _food ? event.getFoodLevel() : food) - oldFoodLevel, info.saturation);
                }
                ((EntityPlayer)human).getBukkitEntity().sendHealthUpdate();
            }
        }, () -> base.eat(item, stack));
    }

    private void tryModifyFoodLevel(EntityHuman player, float delta) {
        float food = Math.max(doubleFood + delta, 0);
        int _food = (int) food;
        FoodLevelChangeEvent event = CraftEventFactory.callFoodLevelChangeEvent(player, _food);
        if (!event.isCancelled()) {
            int __food = event.getFoodLevel();
            if (__food == _food) doubleFood = food;
            else doubleFood = __food;
            base.foodLevel = (int) doubleFood;
        }
        sendChanges(player);
    }
    public float modifyFoodLevel(float delta) {
        tryModifyFoodLevel(human, delta);
        return doubleFood;
    }
    public float modifySaturation(float saturation) {
        base.saturationLevel += saturation;
        sendChanges(human);
        return base.saturationLevel;
    }

    private void sendChanges(EntityHuman player) {
        ((EntityPlayer) player).connection.send(new PacketPlayOutUpdateHealth(((EntityPlayer) player).getBukkitEntity().getScaledHealth(), base.foodLevel, base.saturationLevel));
    }

    @Override public void tick(EntityHuman player) {
        if (base.foodLevel != this.foodLevel) onFoodEdit();

        EnumDifficulty enumdifficulty = player.level.getDifficulty();
        if (base.exhaustionLevel > 4.0f) {
            base.exhaustionLevel -= 4.0f;
            if (base.saturationLevel > 0.0f) base.saturationLevel = Math.max(base.saturationLevel - saturationStep, 0.0f);
            else if (enumdifficulty != EnumDifficulty.PEACEFUL) tryModifyFoodLevel(player, -foodStep);
        }
        float buff = base.exhaustionLevel;
        base.exhaustionLevel = 0;
        base.tick(player);
        base.exhaustionLevel = buff;
        sync();
    }
    
    @Override public void readAdditionalSaveData(NBTTagCompound nbt) {
        base.readAdditionalSaveData(nbt);
        onFoodEdit();
    }
    @Override public void addAdditionalSaveData(NBTTagCompound nbt) { base.addAdditionalSaveData(nbt); }
    @Override public int getLastFoodLevel() { return base.getLastFoodLevel(); }
    @Override public int getFoodLevel() { return base.getFoodLevel(); }
    @Override public boolean needsFood() { return base.needsFood(); }
    @Override public void addExhaustion(float exhaustion) { base.addExhaustion(exhaustion); }
    @Override public float getExhaustionLevel() { return base.getExhaustionLevel(); }
    @Override public float getSaturationLevel() { return base.getSaturationLevel(); }
    @Override public void setFoodLevel(int foodLevel) { base.setFoodLevel(foodLevel); }
    @Override public void setSaturation(float saturationLevel) { base.setSaturation(saturationLevel); }
    @Override public void setExhaustion(float exhaustion) { base.setExhaustion(exhaustion); }

    public static Optional<AnyProxyFoodMetaData> ofPlayer(Player player) {
        return Optional.ofNullable(player)
                .map(v -> v instanceof CraftPlayer c ? c.getHandle() : null)
                .map(AnyProxyFoodMetaData::getProxyFood);
    }
}

















